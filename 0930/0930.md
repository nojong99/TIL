

---

### 캡슐화 데이터 보호 장치 

**private < default < protected < public** 

**데이터는 무조건 ->  private data ///  메서드는 public** 

**메서드를 제한하기 위해서 protected 와 default 를 사용한다**. 



> 객체화 ( has ) 상속 (is)

- public 일때는 모두 가능하고 어디서든 가능  

- private 일때 클래스 앞에는 붙일 수 없다. 

  ##### class 앞에 붙일 수 있을 때는 default or public 만 붙일 수 있다.

- (default) 일때 같은 패키지 내에서만 접근 가능

- protected 일때 다른 패키지에 있어도 자식(상속) 관계라면 접근 가능 



---

# 상속

단일 상속  : super의 모든 멤버 (data, method)를 물려 받는 것 

Private member, 생성자 -->  상속안됨 

 entity (요소, 데이터) service ( 실행, 비즈니스)

---

## 오버로딩

이름이 같은 것 .. 



---

---

복습 



#### [ 클래스 사용방법 ]

1. **객체화**
2. **상속** 

**이 두 방법들을 통해 다른 클래스에 있는 메소드와 변수등을 사용할 수 있다.** 

#### [ 클래스 구조 ]

1. 필드 - 데이터

   - 지정 되지 않은 필드들은 기본 초기값으로 설정된다.  ( 0 or null 등

   

2. 생성자 - 특별한 메서드

   - 없다면 자동적으로 pulbic 클래스명() {super();}이 선언
   - 생성자는 new 를 사용하여야만 호출가능
   - non -static 멤버를 초기화해준다. 

   >다른 생성자 호출 this () 
   >
   >중복되는 코드를 없애기위해 클래스필드에 중복되는 값을 적고, this(전역변수)를 통해 호출
   >
   >같은 클래스명에 매개변수를 다르게 하면 오버로딩이 가능하다. 
   >
   >(단, 타입 개수 순서에 유의해야한다. )

3. 메소드

### 리턴

값을 반환한다.

리턴이 실행된 이후 메소드가 즉시 종료되며 이후의 실행문은 결코 실행되지 않는다. 

#### //객체 외부에서의 호출 //

클래스   | 참초변수  = new 클래스 |(매개변수);

### //메소드 오버로딩//

리턴 타입은 무관 / 메소드이름은 동일 / 매개변수는 달라야한다. **타입 개수 순서** 

리턴 값이 없는 메소드는 리턴 타입을 void 로 해야함 

### 정적 멤버와 Static

공유하는 데이터라고 불리며 클래스 이름으로 호출이 가능하다. 

간편하지만 old 영역에 있는 static 에 너무 많은 값이 저장이 된다면, 엔진이 꺼진다. 

ex) 블로그 방문자 수

### final 필드와 상수

final 필드 -> 변경없이 사용하라. / 할당될 수 없다. /

static final -> 불변의 값, 이름은 모두 대문자로 작성 + 혼합된 이름이라면 _로 분류 

### 접근 제한자 

private  > 모든 외부 클래스

default > 냉장고, 같은 패키지 내 클래스 공유 가능 

protected > 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 가능  

 public > 없음  

​                 ![지정자](C:\Users\nojon\Desktop\TIL\0930\지정자.PNG)

어노 테이션 = ex) @override 

​                                                                  

# 상속

- **extends 뒤에는 단 하나의 부모 클래스만 와야한다!!**
- **final 클래스 = 상속 불가, final 메소드 = 오버라이딩 불가**
- **생성자는 상속받는것이 아니라 호출하는 것이다.**





![쉬운상속](C:\Users\nojon\Desktop\TIL\0930\쉬운상속.PNG)

##### 상속 관계에 있는지 잘 살펴보자 !!







